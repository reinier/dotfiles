local M = {}

local function getAllUsers(config, adminId, callback)
    local headers = {
        ["Authorization"] = "Bearer " .. config.API_AUTH_TOKEN,
        ["Accept"] = "application/json"
    }
    
    local url = "https://moneybird.com/api/v2/" .. adminId .. "/users.json"
    
    hs.http.doAsyncRequest(url, "GET", nil, headers, function(status, responseBody, responseHeaders)
        if status ~= 200 then
            callback(nil, "❌ Failed to get users. Status: " .. status)
            return
        end
        
        local success, users = pcall(hs.json.decode, responseBody)
        if not success or not users then
            callback(nil, "❌ Invalid users response")
            return
        end
        
        callback(users, nil)
    end)
end

local function showUserChooser(config, adminId, callback)
    getAllUsers(config, adminId, function(users, userError)
        if userError then
            callback(nil, userError)
            return
        end
        
        if not users or #users == 0 then
            callback(nil, "❌ No users found")
            return
        end
        
        local chooser = hs.chooser.new(function(choice)
            if choice then
                -- Store the selected user ID
                hs.settings.set("timer.userId", choice.userId)
                callback(choice.userId, nil)
            else
                callback(nil, "❌ No user selected")
            end
        end)
        
        local choices = {}
        for _, user in ipairs(users) do
            local displayName = user.email or "User " .. (user.id or "Unknown")
            if user.first_name or user.last_name then
                displayName = (user.first_name or "") .. " " .. (user.last_name or "")
                displayName = displayName:gsub("^%s+", ""):gsub("%s+$", "") -- trim spaces
                if user.email then
                    displayName = displayName .. " (" .. user.email .. ")"
                end
            end
            
            table.insert(choices, {
                text = displayName,
                subText = "ID: " .. (user.id or "unknown"),
                userId = user.id
            })
        end
        
        -- Sort by name
        table.sort(choices, function(a, b)
            return a.text < b.text
        end)
        
        chooser:choices(choices)
        chooser:placeholderText("Select your user account...")
        chooser:selectedRow(1)  -- Default to first user
        chooser:show()
    end)
end

local function getUserId(config, adminId, callback)
    -- Check if we have a stored user ID
    local storedUserId = hs.settings.get("timer.userId")
    if storedUserId then
        callback(storedUserId, nil)
        return
    end
    
    -- If not, show user chooser
    showUserChooser(config, adminId, callback)
end


function M.resetTimerSettings()
    -- Get all timer-related settings
    local timerKeys = {}
    for _, key in ipairs(hs.settings.getKeys()) do
        if string.match(key, "^timer%.") then
            table.insert(timerKeys, key)
        end
    end
    
    -- Remove all timer settings
    for _, key in ipairs(timerKeys) do
        hs.settings.set(key, nil)
    end
    
    local itemTypes = {}
    local hasUserId = false
    local hasClientCache = false
    local hasProjectCache = false
    local hasUsageCache = false
    local hasDescriptions = false
    local hasApiToken = false
    
    for _, key in ipairs(timerKeys) do
        if key == "timer.userId" then
            hasUserId = true
        elseif key == "timer.cachedClients" then
            hasClientCache = true
        elseif key == "timer.cachedProjects" then
            hasProjectCache = true
        elseif key == "timer.cachedClientUsage" then
            hasUsageCache = true
        elseif key == "timer.lastDescription" or key == "timer.recentDescriptions" then
            hasDescriptions = true
        elseif key == "timer.apiToken" then
            hasApiToken = true
        end
    end
    
    local message = "✅ Timer settings reset! (" .. #timerKeys .. " items cleared)"
    if hasApiToken then message = message .. "\n• API token cleared" end
    if hasUserId then message = message .. "\n• User ID cleared" end
    if hasClientCache then message = message .. "\n• Client cache cleared" end
    if hasProjectCache then message = message .. "\n• Project cache cleared" end
    if hasUsageCache then message = message .. "\n• Usage data cleared" end
    if hasDescriptions then message = message .. "\n• Description history cleared" end
    
    hs.alert.show(message, 4)
end

local function showApiTokenInput(callback)
    local chooser = hs.chooser.new(function(choice)
        if choice then
            local token = choice.text
            -- Save the API token for future use
            hs.settings.set("timer.apiToken", token)
            callback(token, nil)
        else
            callback(nil, "❌ API token input cancelled")
        end
    end)
    
    chooser:placeholderText("Enter your Moneybird API token...")
    chooser:queryChangedCallback(function(query)
        if query and query ~= "" then
            chooser:choices({{text = query, subText = "API Token"}})
        else
            chooser:choices({})
        end
    end)
    
    chooser:show()
end

local function getApiConfig(callback)
    -- First check if we have stored API token
    local storedToken = hs.settings.get("timer.apiToken")
    if storedToken then
        local config = {API_AUTH_TOKEN = storedToken}
        
        -- Try to get default description from secrets if available
        local secrets = hs.settings.get("secrets")
        if secrets and secrets.moneybird and secrets.moneybird.TIMER_DESCRIPTION then
            config.TIMER_DESCRIPTION = secrets.moneybird.TIMER_DESCRIPTION
        else
            config.TIMER_DESCRIPTION = "Work Timer Entry"
        end
        
        callback(config, nil)
        return
    end
    
    -- If not stored, show token input
    showApiTokenInput(function(token, tokenError)
        if tokenError then
            callback(nil, tokenError)
            return
        end
        
        local config = {API_AUTH_TOKEN = token}
        
        -- Try to get default description from secrets if available
        local secrets = hs.settings.get("secrets")
        if secrets and secrets.moneybird and secrets.moneybird.TIMER_DESCRIPTION then
            config.TIMER_DESCRIPTION = secrets.moneybird.TIMER_DESCRIPTION
        else
            config.TIMER_DESCRIPTION = "Work Timer Entry"
        end
        
        callback(config, nil)
    end)
end

local function getCurrentUTCTimestamp()
    return os.date("!%Y-%m-%d %H:%M:%S UTC")
end

local function makeAPIRequest(method, url, headers, body, callback)
    hs.http.doAsyncRequest(url, method, body, headers, callback)
end

local function getAdministrationId(config, callback)
    local headers = {
        ["Authorization"] = "Bearer " .. config.API_AUTH_TOKEN,
        ["Accept"] = "application/json"
    }
    
    local url = "https://moneybird.com/api/v2/administrations.json"
    
    hs.http.doAsyncRequest(url, "GET", nil, headers, function(status, responseBody, responseHeaders)
        if status ~= 200 then
            callback(nil, "❌ Failed to get administrations. Status: " .. status)
            return
        end
        
        local success, administrations = pcall(hs.json.decode, responseBody)
        if not success or not administrations or #administrations == 0 then
            callback(nil, "❌ Invalid or empty administrations response")
            return
        end
        
        callback(administrations[1].id, nil)
    end)
end

local function getProjects(config, adminId, callback)
    -- Check if we have cached projects
    local cachedProjects = hs.settings.get("timer.cachedProjects")
    if cachedProjects then
        print("DEBUG: Using cached projects, count:", #cachedProjects)
        callback(cachedProjects, nil)
        return
    end
    
    -- If not cached, fetch from API
    hs.alert.show("ℹ️ Fetching projects from API...", 2)
    
    local headers = {
        ["Authorization"] = "Bearer " .. config.API_AUTH_TOKEN,
        ["Accept"] = "application/json"
    }
    
    local url = "https://moneybird.com/api/v2/" .. adminId .. "/projects.json"
    
    hs.http.doAsyncRequest(url, "GET", nil, headers, function(status, responseBody, responseHeaders)
        if status ~= 200 then
            callback(nil, "❌ Failed to get projects. Status: " .. status)
            return
        end
        
        local success, projects = pcall(hs.json.decode, responseBody)
        if not success or not projects then
            callback(nil, "❌ Invalid projects response")
            return
        end
        
        -- Cache the projects for future use
        hs.settings.set("timer.cachedProjects", projects)
        hs.settings.set("timer.projectsCachedAt", os.time())
        print("DEBUG: Cached", #projects, "projects at", os.time())
        
        callback(projects, nil)
    end)
end

local function getClients(config, adminId, callback)
    -- Check if we have cached clients
    local cachedClients = hs.settings.get("timer.cachedClients")
    if cachedClients then
        print("DEBUG: Using cached clients, count:", #cachedClients)
        callback(cachedClients, nil)
        return
    end
    
    -- If not cached, fetch from API
    hs.alert.show("ℹ️ Fetching clients from API...", 2)
    
    local headers = {
        ["Authorization"] = "Bearer " .. config.API_AUTH_TOKEN,
        ["Accept"] = "application/json"
    }
    
    local url = "https://moneybird.com/api/v2/" .. adminId .. "/contacts.json"
    
    hs.http.doAsyncRequest(url, "GET", nil, headers, function(status, responseBody, responseHeaders)
        if status ~= 200 then
            callback(nil, "❌ Failed to get clients. Status: " .. status)
            return
        end
        
        local success, clients = pcall(hs.json.decode, responseBody)
        if not success or not clients then
            callback(nil, "❌ Invalid clients response")
            return
        end
        
        -- Cache the clients for future use
        hs.settings.set("timer.cachedClients", clients)
        hs.settings.set("timer.clientsCachedAt", os.time())
        print("DEBUG: Cached", #clients, "clients at", os.time())
        
        callback(clients, nil)
    end)
end

local function getRecentClientUsage(config, adminId, callback)
    -- Check if we have cached usage data (refresh every hour)
    local cachedUsage = hs.settings.get("timer.cachedClientUsage")
    local cachedAt = hs.settings.get("timer.clientUsageCachedAt") or 0
    local oneHourAgo = os.time() - (60 * 60) -- 1 hour in seconds
    
    if cachedUsage and cachedAt > oneHourAgo then
        callback(cachedUsage, nil)
        return
    end
    
    local headers = {
        ["Authorization"] = "Bearer " .. config.API_AUTH_TOKEN,
        ["Accept"] = "application/json"
    }
    
    -- Get recent time entries to determine most used clients
    local url = "https://moneybird.com/api/v2/" .. adminId .. "/time_entries.json"
    
    hs.http.doAsyncRequest(url, "GET", nil, headers, function(status, responseBody, responseHeaders)
        if status ~= 200 then
            callback({}, nil) -- Return empty usage if we can't get time entries
            return
        end
        
        local success, timeEntries = pcall(hs.json.decode, responseBody)
        if not success or not timeEntries then
            callback({}, nil)
            return
        end
        
        -- Count client usage and track most recent usage
        local clientUsage = {}
        for _, entry in ipairs(timeEntries) do
            if entry.contact_id then
                local clientId = tostring(entry.contact_id)
                if not clientUsage[clientId] then
                    clientUsage[clientId] = {count = 0, lastUsed = ""}
                end
                clientUsage[clientId].count = clientUsage[clientId].count + 1
                -- Keep track of most recent usage
                if entry.started_at and (clientUsage[clientId].lastUsed < entry.started_at) then
                    clientUsage[clientId].lastUsed = entry.started_at
                end
            end
        end
        
        -- Cache the usage data for future use (valid for 1 hour)
        hs.settings.set("timer.cachedClientUsage", clientUsage)
        hs.settings.set("timer.clientUsageCachedAt", os.time())
        
        callback(clientUsage, nil)
    end)
end



local function showClientChooser(config, adminId, callback)
    -- Get both clients and their usage data
    getClients(config, adminId, function(clients, clientError)
        if clientError then
            callback(nil, clientError)
            return
        end
        
        if not clients or #clients == 0 then
            callback(nil, "❌ No clients found")
            return
        end
        
        getRecentClientUsage(config, adminId, function(clientUsage, usageError)
            -- Continue even if usage data fails
            if usageError then
                clientUsage = {}
            end
            
            local chooser = hs.chooser.new(function(choice)
                if choice then
                    callback(choice.clientId, nil)
                else
                    callback(nil, "❌ No client selected")
                end
            end)
            
            -- Sort clients by recent usage, then alphabetically
            local sortedClients = {}
            for _, client in ipairs(clients) do
                local clientId = tostring(client.id)
                local usage = clientUsage[clientId] or {count = 0, lastUsed = ""}
                
                table.insert(sortedClients, {
                    client = client,
                    usage = usage
                })
            end
            
            -- Sort by last used date (most recent first), then by usage count, then by name
            table.sort(sortedClients, function(a, b)
                if a.usage.lastUsed ~= b.usage.lastUsed then
                    return a.usage.lastUsed > b.usage.lastUsed
                end
                if a.usage.count ~= b.usage.count then
                    return a.usage.count > b.usage.count
                end
                return (a.client.company_name or a.client.firstname or "Unknown") < (b.client.company_name or b.client.firstname or "Unknown")
            end)
            
            local choices = {}
            for _, item in ipairs(sortedClients) do
                local client = item.client
                local usage = item.usage
                
                local displayName = client.company_name or 
                                  (client.firstname and client.lastname and (client.firstname .. " " .. client.lastname)) or 
                                  client.firstname or "Unknown Client"
                
                local subText = "ID: " .. (client.id or "unknown")
                if usage.count > 0 then
                    subText = subText .. " • Used " .. usage.count .. " times"
                    if usage.lastUsed and usage.lastUsed ~= "" then
                        subText = subText .. " • Last: " .. string.sub(usage.lastUsed, 1, 10) -- Just the date part
                    end
                end
                
                table.insert(choices, {
                    text = displayName,
                    subText = subText,
                    clientId = client.id
                })
            end
            
            chooser:choices(choices)
            chooser:placeholderText("Select client for timer...")
            chooser:selectedRow(1)  -- Default to first (most recently used) client
            chooser:show()
        end)
    end)
end

local function showDescriptionInput(callback)
    -- Get last used description and common descriptions
    local lastDescription = hs.settings.get("timer.lastDescription") 
    local recentDescriptions = hs.settings.get("timer.recentDescriptions") or {}
    
    local chooser = hs.chooser.new(function(choice)
        if choice then
            local description = choice.text
            -- Save the description for next time
            hs.settings.set("timer.lastDescription", description)
            
            -- Add to recent descriptions (keep last 5, avoid duplicates)
            local newRecent = {description}
            for _, desc in ipairs(recentDescriptions) do
                if desc ~= description and #newRecent < 5 then
                    table.insert(newRecent, desc)
                end
            end
            hs.settings.set("timer.recentDescriptions", newRecent)
            
            callback(description, nil)
        else
            callback(nil, "❌ Timer cancelled")
        end
    end)
    
    -- Build choices list with recent descriptions
    local choices = {}
    
    -- Add last used description first (if exists)
    if lastDescription then
        table.insert(choices, {
            text = lastDescription,
            subText = "Last used"
        })
    end
    
    -- Add other recent descriptions
    for _, desc in ipairs(recentDescriptions) do
        if desc ~= lastDescription then
            table.insert(choices, {
                text = desc,
                subText = "Recent"
            })
        end
    end
    
    -- Add some common defaults if no recent descriptions
    if #choices == 0 then
        local defaults = {
            "Work Timer Entry",
            "Development work", 
            "Meeting",
            "Code review",
            "Documentation"
        }
        for _, desc in ipairs(defaults) do
            table.insert(choices, {
                text = desc,
                subText = "Suggested"
            })
        end
    end
    
    chooser:choices(choices)
    chooser:placeholderText("Enter timer description...")
    chooser:selectedRow(1) -- Default to first choice (last used)
    
    -- Allow typing custom descriptions
    chooser:queryChangedCallback(function(query)
        if query and query ~= "" then
            -- Show typed text as first option
            local newChoices = {{text = query, subText = "Custom"}}
            -- Add existing choices that match
            for _, choice in ipairs(choices) do
                if string.find(string.lower(choice.text), string.lower(query), 1, true) then
                    table.insert(newChoices, choice)
                end
            end
            chooser:choices(newChoices)
        else
            chooser:choices(choices)
        end
    end)
    
    chooser:show()
end

local function createTimeEntry(config, adminId, projectId, clientId, description, callback)
    getUserId(config, adminId, function(userId, userError)
        if userError then
            callback(nil, userError)
            return
        end
        
        local headers = {
            ["Authorization"] = "Bearer " .. config.API_AUTH_TOKEN,
            ["Content-Type"] = "application/json",
            ["Accept"] = "application/json"
        }
        
        local timeEntry = {
            time_entry = {
                description = description,
                contact_id = tostring(clientId),
                project_id = tostring(projectId),
                user_id = tostring(userId),
                started_at = getCurrentUTCTimestamp(),
                billable = true
            }
        }
        
        local url = "https://moneybird.com/api/v2/" .. adminId .. "/time_entries.json"
        local body = hs.json.encode(timeEntry)
        
        hs.http.doAsyncRequest(url, "POST", body, headers, function(status, responseBody, responseHeaders)
            if status ~= 201 and status ~= 200 then
                local errorMsg = "❌ Failed to create time entry. Status: " .. status
                if responseBody then
                    errorMsg = errorMsg .. "\n" .. responseBody
                end
                callback(nil, errorMsg)
                return
            end
            
            local success, response = pcall(hs.json.decode, responseBody)
            if not success or not response then
                callback(nil, "❌ Invalid response from time entry creation")
                return
            end
            
            callback(response, nil)
        end)
    end)
end

local function showProjectChooser(config, adminId, callback)
    getProjects(config, adminId, function(projects, projectError)
        if projectError then
            callback(nil, projectError)
            return
        end
        
        if not projects or #projects == 0 then
            callback(nil, "❌ No projects found")
            return
        end
        
        local chooser = hs.chooser.new(function(choice)
            if choice then
                callback(choice.projectId, nil)
            else
                callback(nil, "❌ No project selected")
            end
        end)
        
        local choices = {}
        for i, project in ipairs(projects) do
            table.insert(choices, {
                text = project.name or "Unknown Project",
                subText = "ID: " .. (project.id or "unknown"),
                projectId = project.id
            })
        end
        
        chooser:choices(choices)
        chooser:placeholderText("Select project for timer...")
        chooser:selectedRow(1)  -- Default to first project
        chooser:show()
    end)
end


function M.debugActiveTimers(callback)
    getApiConfig(function(config, configError)
        if configError then
            callback(nil, configError)
            return
        end
    
    hs.alert.show("ℹ️ Fetching active timers for debugging...", 2)
    
    getAdministrationId(config, function(adminId, adminError)
        if adminError then
            callback(nil, adminError)
            return
        end
        
        local headers = {
            ["Authorization"] = "Bearer " .. config.API_AUTH_TOKEN,
            ["Accept"] = "application/json"
        }
        
        -- Try different URL parameter approaches
        local urls = {
            -- Basic without filters
            "https://moneybird.com/api/v2/" .. adminId .. "/time_entries.json",
            -- With include_active only
            "https://moneybird.com/api/v2/" .. adminId .. "/time_entries.json?include_active=true",
            -- With different date formats
            "https://moneybird.com/api/v2/" .. adminId .. "/time_entries.json?include_active=true&day=" .. os.date("!%Y-%m-%d"),
            "https://moneybird.com/api/v2/" .. adminId .. "/time_entries.json?include_active=true&day=" .. os.date("!%Y%m%d"),
            -- With limit to reduce results
            "https://moneybird.com/api/v2/" .. adminId .. "/time_entries.json?include_active=true&per_page=10",
        }
        
        local function testUrl(index)
            if index > #urls then
                callback(nil, "All URL tests completed - check console")
                return
            end
            
            local url = urls[index]
            
            print("\n=== TESTING URL " .. index .. " ===")
            print("URL:", url)
            
            hs.http.doAsyncRequest(url, "GET", nil, headers, function(status, responseBody, responseHeaders)
                print("Status:", status)
                
                if status ~= 200 then
                    print("Failed with status:", status)
                    print("Response:", responseBody or "nil")
                else
                    local success, timeEntries = pcall(hs.json.decode, responseBody)
                    if success and timeEntries then
                        print("Total entries returned:", #timeEntries)
                        
                        -- Show first 3 entries with key details
                        for i, entry in ipairs(timeEntries) do
                            if i <= 3 then
                                print(string.format("\n--- Entry %d ---", i))
                                print("ID:", entry.id or "nil")
                                print("Description:", entry.description or "nil") 
                                print("Started at:", entry.started_at or "nil")
                                print("Ended at:", entry.ended_at or "nil")
                                
                                -- Check if this looks like an active timer
                                local isActive = entry.started_at and not entry.ended_at
                                print("APPEARS ACTIVE:", tostring(isActive))
                            end
                        end
                    else
                        print("Failed to parse JSON")
                    end
                end
                
                -- Test next URL after a delay
                hs.timer.doAfter(1, function() testUrl(index + 1) end)
            end)
        end
        
        testUrl(1)
    end)
end

function M.startTimer(callback)
    getApiConfig(function(config, configError)
        if configError then
            callback(nil, configError)
            return
        end
    
    -- Check if we have user ID stored, if not show user chooser first
    local storedUserId = hs.settings.get("timer.userId")
    if not storedUserId then
        hs.alert.show("ℹ️ Select your user account", 2)
    end
    
    getAdministrationId(config, function(adminId, adminError)
        if adminError then
            callback(nil, adminError)
            return
        end
        
        -- Get/set user ID first (will show chooser if needed)
        getUserId(config, adminId, function(userId, userError)
            if userError then
                callback(nil, userError)
                return
            end
            
            -- Don't show loading message here - getClients will show appropriate message
            
            showClientChooser(config, adminId, function(clientId, clientError)
                if clientError then
                    callback(nil, clientError)
                    return
                end
                
                -- Don't show loading message here - getProjects will show appropriate message
                
                showProjectChooser(config, adminId, function(projectId, projectError)
                    if projectError then
                        callback(nil, projectError)
                        return
                    end
                    
                    showDescriptionInput(function(description, descriptionError)
                        if descriptionError then
                            callback(nil, descriptionError)
                            return
                        end
                        
                        createTimeEntry(config, adminId, projectId, clientId, description, function(timeEntry, entryError)
                            if entryError then
                                callback(nil, entryError)
                                return
                            end
                            
                            local successMsg = "✅ Timer started!"
                            callback(timeEntry, successMsg)
                        end)
                    end)
                end)
            end)
        end)
    end)
end

return M